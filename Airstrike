# Project Part 3 - Airstrike
# Author(s): Andrew Banuelos and David Ke
# Course: CS110, Fall 2021
# Final Turn-in Options: 
# DOCUMENTATION:

import random
import drone_api
from cs110 import autograder
from drone_api import set_destination
from drone_api import get_x_location
from drone_api import get_y_location
from drone_api import destination_reached
from drone_api import taking_off
from drone_api import mission_complete
from drone_api import engage_hyperspeed
from drone_api import engage_plaidspeed
from drone_api import get_scan_results
from drone_api import intel_report
from drone_api import deploy_air_to_ground
from drone_api import get_bomb_inventory
from drone_api import ignore_drone_damage
from drone_api import get_drone_health

#Lets see if pull requests work
# MAP_SEED = "two"
MAP_SEED = "three"
# MAP_SEED = "five"
# MAP_SEED = "SAM-protected"
# MAP_SEED = "test range"

# 1-min scans, 2-min bomber dmg, 3-varying bomb damage, 4-Advanced SAMs, 5-limited bomb capacity
# include desired mode numbers in list variable below
challenge_modes = []


base_uniqueID = []
base_coordinates = []

bases_bombed = 0
SAMx = 0
SAMy = 0

recon_x = -1
recon_y = -1

# Finds the distance between 2 sets of coordinates
# Parameters: 4 integers (2 sets of x, y coordinates)
# Return: float
def distance_from(x, y, x2, y2):
    return ((x-x2)**2 + (y-y2)**2)**0.5
# looks to see if a certain point is in the radius of another. If it is, returns True, if not, returns False.
def in_circle(x1, y1, cir_x, cir_y, radius):
    distance = ((cir_x-x1)**2 + (cir_y-y1)**2)**.5
    if distance <= radius:
        return True
    if distance > radius:
        return False
    
def drone_recon():
    ignore_drone_damage()
    global recon_x, recon_y, SAMx, SAMy, bases_bombed
    x_drone = get_x_location()
    y_drone = get_y_location()
    recon_x = x_drone
    recon_y = y_drone
    num_bases = intel_report()
    
    # If the recon drone is within SAM range, then it doesn't scan
    if in_circle(x_drone, y_drone, SAMx, SAMy, 200) == False:
        for target in get_scan_results():
            if target[0] == 'SAM':
                SAMx = int(target[5])
                SAMy = int(target[6])
            if target[0] == 'base':
                if base_uniqueID.count(target[7]) == 0:
                    base_uniqueID.append(target[7])
                    base_location = [int(target[5]), int(target[6])]
                    base_coordinates.append(base_location)
    #added code to end when bombed bases is equal to total number on map.
    if bases_bombed == num_bases:
                mission_complete()
#drone flight path
    if taking_off():
        set_destination(1025, 850)
    if destination_reached() and x_drone == 1025 and y_drone == 850:
        set_destination(1700, 800)
    if destination_reached() and x_drone == 1700 and y_drone == 800:
            set_destination(1600, 100)
    if destination_reached() and x_drone == 1600 and y_drone == 100:
        set_destination(1200, 150)
    if destination_reached() and x_drone == 1200 and y_drone == 150:
        set_destination(1200, 525)
    if destination_reached() and x_drone == 1200 and y_drone == 525:
        set_destination(850, 125)
    if destination_reached() and x_drone == 850 and y_drone == 125:
        set_destination(475, 125)
    if destination_reached() and x_drone == 475 and y_drone == 125:
        set_destination(475, 800)
    if destination_reached() and x_drone == 475 and y_drone == 800:
        set_destination(750, 800)
        
def drone_bomber():
    global bases_bombed
    ignore_drone_damage()
    num_bases = intel_report()
    num_bombs = get_bomb_inventory()
    x_drone = get_x_location()
    y_drone = get_y_location()
    #added if statements to differentiate when bomber needed to resuply
    if num_bombs == 0:
        set_destination(100,500)
    elif num_bombs != 0:
        if len(base_coordinates) > 0:
            base_x = base_coordinates[0][0]
            base_y = base_coordinates[0][1]
            set_destination(base_x, base_y)        
            if (destination_reached() and x_drone == base_x and y_drone == base_y) or distance_from(x_drone, y_drone, base_x, base_y) <= 100:
                deploy_air_to_ground(base_x, base_y)
                del base_coordinates[0]
                #changed code
                bases_bombed = bases_bombed +1
    else:
        set_destination(recon_x, recon_y)

# This loads the simulation scenario
# DO NOT TOUCH
if __name__ == "__main__":
    import Scenario3
    
