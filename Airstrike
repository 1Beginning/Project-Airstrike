# Project Part 3 - Airstrike
# Author(s): Andrew Banuelos and David Ke
# Course: CS110, Fall 2021
# Final Turn-in Options: 
# DOCUMENTATION:

import random
import drone_api
from cs110 import autograder
from drone_api import set_destination
from drone_api import get_x_location
from drone_api import get_y_location
from drone_api import destination_reached
from drone_api import taking_off
from drone_api import mission_complete
from drone_api import engage_hyperspeed
from drone_api import engage_plaidspeed
from drone_api import get_scan_results
from drone_api import intel_report
from drone_api import deploy_air_to_ground
from drone_api import get_bomb_inventory
from drone_api import ignore_drone_damage
from drone_api import get_drone_health

#Lets see if pull requests work
# MAP_SEED = "two"
MAP_SEED = "three"
# MAP_SEED = "five"
# MAP_SEED = "SAM-protected"
# MAP_SEED = "test range"

# 1-min scans, 2-min bomber dmg, 3-varying bomb damage, 4-Advanced SAMs, 5-limited bomb capacity
# include desired mode numbers in list variable below
challenge_modes = []

base_uniqueID = []
base_coordinates = []
SAM_ID = []
SAM_coordinates = []
SAM_RADIUS = 200

# Locates and stores the ID's and coordinates of unique bases and SAM sites into global lists
# Parameter: 2D list (scanned results)
# Return: None
def locate_targets(targets):
    for target in targets:
        if target[0] == 'base':
            if base_uniqueID.count(target[7]) == 0:
                base_uniqueID.append(target[7])
                base_location = [target[5], target[6]]
                base_coordinates.append(base_location)
        elif target[0] == 'SAM':
            if SAM_ID.count(target[7]) == 0:
                SAM_ID.append(target[7])
                SAM_location = [target[5], target[6]]
                SAM_coordinates.append(SAM_location)

# Finds the distance between 2 sets of coordinates
# Parameters: 4 integers (2 sets of x, y coordinates)
# Return: float
def distance_from(x, y, x2, y2):
    return ((x-x2)**2 + (y-y2)**2)**0.5

# Identifies closest SAM site and tells whether the drone is inside its range
# Parameters: 2 integers (x and y of either drone)
# Return: boolean
def within_SAM_range(d_x, d_y):
    global SAM_RADIUS
    i = 0
    for n in range(len(SAM_ID)):
        if distance_from(d_x, d_y, SAM_coordinates[i][0], SAM_coordinates[i][1]) < distance_from(d_x, d_y, SAM_coordinates[n][0], SAM_coordinates[n][1]):
            i = n
    if len(SAM_ID) == 0:
        return False
    return distance_from(d_x, d_y, SAM_coordinates[i][0], SAM_coordinates[i][1]) <= SAM_RADIUS

# Finds the line equation of the drones path, then finds whether it intersects any of the SAM sites
# It does this by plugging in the equation of the line into the equation of the circle and solving for x
# Since it simplifies to a quadratic equation, if the determinant is negative, it doesn't intersect (b/c sqrt(neg)-->DNE)
# Parameters: 4 integers (2 sets of x,y coordinates for the drone and 1 for a base)
# Returns a list of SAM site indexs that intersect the drones path
def intersects_SAM_range(d_x, d_y, b_x, b_y):
# Since this is still progress, the return [] just exits out immediately
    return []
    intersected_SAMs = []
    index = 0
    
    # (x-x0)^2 + (y-y0)^2 = r^2
    r = SAM_RADIUS
    # y = mx + y_intercept
    m = (d_y-b_y)/(d_x-b_x)
    y_intercept = d_y-m*d_x
    
    for sam in SAM_coordinates:
        # ax^2 + bx + c
        a = m**2 + 1
        b = 2*(y_intercept-sam[1])*m - 2*sam[0]
        c = sam[0]**2 + (y_intercept - sam[1])**2 - r**2
        # d = b^2 - 4ac, from quadratic equation
        determinant = b**2 - 4*a*c
        if determinant > 0:
            intersected_SAMs.append(index)
        index += 1
    return intersected_SAMs


def drone_recon():
    ignore_drone_damage()
    
    global start_bomber, recon_x, recon_y
    x_drone = get_x_location()
    y_drone = get_y_location()
    num_bases = intel_report()
    
    # If the recon drone is within SAM range, then it doesn't scan
    if not within_SAM_range(x_drone, y_drone):
        locate_targets(get_scan_results())
    
    if taking_off():
        set_destination(1600, 800)
    if destination_reached() and x_drone == 1600 and y_drone == 800:
        set_destination(1600, 200)
    if destination_reached() and x_drone == 1600 and y_drone == 200:
            set_destination(600, 500)
            
def drone_bomber():
    ignore_drone_damage()
    num_bases = intel_report()
    num_bombs = get_bomb_inventory()
    x_drone = get_x_location()
    y_drone = get_y_location()

    if len(base_coordinates) > 0:
        base_x = base_coordinates[0][0]
        base_y = base_coordinates[0][1]
        if len(intersects_SAM_range(x_drone, y_drone, base_x, base_y)) == 0:
            set_destination(base_x, base_y)
        if distance_from(x_drone, y_drone, base_x, base_y) <= 100:
            deploy_air_to_ground(base_x, base_y)
            del base_coordinates[0]
            
    if num_bombs == 10-num_bases:
        mission_complete()

# This loads the simulation scenario
# DO NOT TOUCH
if __name__ == "__main__":
    import Scenario3
    
