# Project Part 3 - Airstrike
# Author(s): Andrew Banuelos and David Ke
# Course: CS110, Fall 2021
# Final Turn-in Options: 
# DOCUMENTATION:

import random
import drone_api
from cs110 import autograder
from drone_api import set_destination
from drone_api import get_x_location
from drone_api import get_y_location
from drone_api import destination_reached
from drone_api import taking_off
from drone_api import mission_complete
from drone_api import engage_hyperspeed
from drone_api import engage_plaidspeed
from drone_api import get_scan_results
from drone_api import intel_report
from drone_api import deploy_air_to_ground
from drone_api import get_bomb_inventory
from drone_api import ignore_drone_damage
from drone_api import get_drone_health

#Lets see if pull requests work
# MAP_SEED = "two"
MAP_SEED = "three"
# MAP_SEED = "five"
# MAP_SEED = "SAM-protected"
# MAP_SEED = "test range"

# 1-min scans, 2-min bomber dmg, 3-varying bomb damage, 4-Advanced SAMs, 5-limited bomb capacity
# include desired mode numbers in list variable below
challenge_modes = []

base_uniqueID = []
base_coordinates = []
SAM_ID = []
SAM_coordinates = []

recon_x = -1
recon_y = -1

# Locates and stores the ID's and coordinates of unique bases and SAM sites into global lists
# Parameter: 2D list (scanned results)
# Return: None
def locate_targets(targets):
    for target in targets:
        if target[0] == 'base':
            if base_uniqueID.count(target[7]) == 0:
                base_uniqueID.append(target[7])
                base_location = [target[5], target[6]]
                base_coordinates.append(base_location)
        elif target[0] == 'SAM':
            if SAM_ID.count(target[7]) == 0:
                SAM_ID.append(target[7])
                SAM_location = [target[5], target[6]]
                SAM_coordinates.append(SAM_location)

# Finds the distance between 2 sets of coordinates
# Parameters: 4 integers (2 sets of x, y coordinates)
# Return: float
def distance_from(x, y, x2, y2):
    return ((x-x2)**2 + (y-y2)**2)**0.5

# Identifies closest SAM site and tells whether the drone is inside its range
# Parameters: 2 integers (x and y of either drone)
# Return: boolean
def within_SAM_range(d_x, d_y):
    i = 0
    for n in range(len(SAM_ID)):
        if distance_from(d_x, d_y, SAM_coordinates[i][0], SAM_coordinates[i][1]) < distance_from(d_x, d_y, SAM_coordinates[n][0], SAM_coordinates[n][1]):
            i = n
    if len(SAM_ID) == 0:
        return False
    return distance_from(d_x, d_y, SAM_coordinates[i][0], SAM_coordinates[i][1]) <= 200

def drone_recon():
    ignore_drone_damage()
    
    global start_bomber, recon_x, recon_y
    x_drone = get_x_location()
    y_drone = get_y_location()
    recon_x = x_drone
    recon_y = y_drone
    num_bases = intel_report()
    
    # If the recon drone is within SAM range, then it doesn't scan
    if not within_SAM_range(x_drone, y_drone):
        locate_targets(get_scan_results())
    # recon drone now scans entire map (but I'm sure the bomber drone will always kill all bases before recon drone gets to scan all of it)
    if taking_off():
        set_destination(1025, 850)
    if destination_reached() and x_drone == 1025 and y_drone == 850:
        set_destination(1700, 800)
    if destination_reached() and x_drone == 1700 and y_drone == 800:
            set_destination(1600, 100)
    if destination_reached() and x_drone == 1600 and y_drone == 100:
        set_destination(1200, 150)
    if destination_reached() and x_drone == 1200 and y_drone == 150:
        set_destination(1200, 525)
    if destination_reached() and x_drone == 1200 and y_drone == 525:
        set_destination(850, 125)
    if destination_reached() and x_drone == 850 and y_drone == 125:
        set_destination(475, 125)
    if destination_reached() and x_drone == 475 and y_drone == 125:
        set_destination(475, 800)
    if destination_reached() and x_drone == 475 and y_drone == 800:
        set_destination(750, 800)
            
def drone_bomber():
    ignore_drone_damage()
    num_bases = intel_report()
    num_bombs = get_bomb_inventory()
    x_drone = get_x_location()
    y_drone = get_y_location()

    if len(base_coordinates) > 0:
        base_x = base_coordinates[0][0]
        base_y = base_coordinates[0][1]
        set_destination(base_x, base_y)        
        if (destination_reached() and x_drone == base_x and y_drone == base_y) or distance_from(x_drone, y_drone, base_x, base_y) <= 100:
            deploy_air_to_ground(base_x, base_y)
            del base_coordinates[0]
    else:
        set_destination(recon_x, recon_y)
    if num_bombs == 10-num_bases:
        mission_complete()

# This loads the simulation scenario
# DO NOT TOUCH
if __name__ == "__main__":
    import Scenario3
    
